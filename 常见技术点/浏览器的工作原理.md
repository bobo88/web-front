# 浏览器的工作原理

*从用户在浏览器地址栏输入网址，到看到整个页面，中间都发生了哪些事情？*

### 一、HTTP请求阶段
- 1、`DNS`解析
    - 原因：人类容易记住域名，而计算机在网络通信过程中，无法认识域名，只能识别IP地址
    - DNS（Domain Name System）是“域名系统”的缩写。
    - 工作原理：将 域名 转换为 IP地址
    - 查询解析过程： 操作系统本地的hosts文件 --> 本地DNS解析器缓存 --> 本地DNS服务器 --> 根DNS服务器
    - 备注：
        - 访问根DNS服务器时，会根据这个域名（比如.com）来判断是谁来授权管理，并返回一个负责该顶级域名服务器的一个IP
        - 负责.com域的服务器收到请求后，如果自己无法解析，会找管理.com域的下一级DNS服务器地址(http://google.com)给本地DNS服务器
        - 不管经历几次往返查询，最终都是将结果（IP地址）返回给本地DNS服务器，由此DNS服务器再返回给客户机
        - 从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间的交互查询就是迭代查询

- 2、`TCP`协议的三次握手和四次挥手
    - 前言：http是一种建立在TCP连接基础上的通信协议，要做一次http请求，首先就是要建立TCP连接
    - `TCP`连接是全双工通道，要建立一条全双工的数据通道，首先确认通道双方的数据收发能力是必须的，而三次握手，做的正是这个校验的操作：
        - 第一次握手：由客户端向服务端发起连接请求，服务端收到客户的请求，确认了客户端的消息发送是没有问题的
        - 第二次握手：由服务端向客户端发送可以建立连接的确认消息，客户端收到后，即可确认服务端的收发都是正常的
        - 第三次握手：由客户端向服务端发送确认消息，服务端收到后，即确认了客户端的接收能力是正常的，至此可以愉快的开始交流了
    - `TCP`连接验证通过（也就是说经过三次握手验证通过），并进行数据交互完成后，自然是要关闭通道，节省资源的，但关闭通道的前提是双方都要确认对方已经没有数据要发送了，所以就有了四次挥手的操作：
        - 第一次挥手：由客户端1通知客户端2，己方已经没有消息要发送给客户端2了
        - 第二次挥手：由客户端2通知客户端1，已收到通知
        - 第三次挥手：由客户端2通知客户端1，己方已经没有消息要发送给客户端1了
        - 第四次挥手：由客户端1通知客户端2，已收到通知
        - 简单来说，流程是： 1 --> 2， `2 -- 1， 2 -- 1，` 1 -- 2。
    - 经过四次挥手操作后，客户端1、2都已经确认双方不会再发送消息，随关闭通道
    - 备注：
        - 全双工（full-duplex）的系统允许二台设备间同时进行双向数据传输。一般的电话、手机就是全双工的系统，因为在讲话时同时也可以听到对方的声音。全双工的系统可以用一般的双向车道形容。两个方向的车辆因使用不同的车道，因此不会互相影响

- 3、`HTTPS` 和 `HTTP（HTTP2）` 的区别
    - 2.0多路复用

- 4、浏览器HTTP请求并发数和TCP连接的关系
    - 当我们打开一个网页时，浏览器对网页中对http并发请求是有个数限制的。
        - 限制是针对域名的，即针对同一域名（包括二级域名）在同一时间支持的并发请求数量的限制。
        - 如果请求数目超出限制，则会阻塞
        - 不同浏览器的默认请求数目限制不同
        - 引申：有时候为了加速获取页面资源的速度，会将图片等静态资源使用不同的一级域名
    - xx


### 二、HTTP相应阶段
- `HTTP`状态码
- `304`缓存
- `HTTP`报文

### 三、浏览器渲染阶段
- 进程 Process
- 线程 Thread
- 栈内存 Stack

备注： 浏览器是多线程的，js是单线程的
- *1、拿到代码后：浏览器在内存条中开辟出一块栈内存，用来给代码的执行提供环境*
- *2、同时分配一个主线程去一行行的解析和执行代码*
- *3、当浏览器遇到link/script/img等请求时，都会开辟全新的线程去加载资源文件 - Task queue任务队列*
- *4、第一次自上而下走完后，只生成DOM树*
- *5、Event Loop 事件循环（找Task queue任务队列中的任务，将完成的任务插入主线程）*
- *6、微任务和宏任务*
- *7、CSS处理完成生成CSSOM*
- *8、DOM树 + CSSOM，合并生成Render Tree渲染树*
    - Layout（回流）：根据生成的渲染树，计算它们在设备视口（viewport）内的确切位置和大小，这个计算的阶段就是回流。
        - 放弃传统操作DOM的时代，基于vue/react开始数据影响视图模式： mvvm/mvc/(virtual dom)/(dom diff)...
        - 分离读写操作（现代的浏览器都有渲染队列的机制）
        - 样式集中改变（批量处理）
    - Painting（重绘）：根据渲染树以及回流得到的几何信息，得到节点的绝对像素
    - Display：将像素发送给GPU，展示到页面上
    - 注意：回流一定会触发重绘，但是重绘不一定会回流
- *9、CPU根据Render Tree渲染树进行页面绘图*
- *10、性能优化：减少HTTP的请求次数以及大小*
    - 资源合并压缩
    - 图片懒加载
    - 音视频走流文件 - m3u8
    - DNS/304缓存
    - ......
